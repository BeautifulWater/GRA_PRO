var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/commands/generators/utils.ts
var utils_exports = {};
__export(utils_exports, {
  GeneratorHelper: () => GeneratorHelper,
  checkStatus: () => checkStatus,
  getUmiJsPlugin: () => getUmiJsPlugin,
  promptsExitWhenCancel: () => promptsExitWhenCancel,
  trim: () => trim
});
module.exports = __toCommonJS(utils_exports);
var import_utils = require("@umijs/utils");
var import_fs = require("fs");
var import_path = require("path");
var import_set = require("../config/set");
function hasDeps({ name, pkg }) {
  var _a, _b;
  return ((_a = pkg.dependencies) == null ? void 0 : _a[name]) || ((_b = pkg.devDependencies) == null ? void 0 : _b[name]);
}
function checkStatus({ pkg }) {
  let needInstall = true;
  if (hasDeps({ pkg, name: "@umijs/plugins" }) || hasDeps({ pkg, name: "@umijs/max" }) || hasDeps({ pkg, name: "@alipay/bigfish" })) {
    needInstall = false;
  }
  let needConfigPlugins = true;
  if (hasDeps({ pkg, name: "@umijs/max" }) || hasDeps({ pkg, name: "@alipay/bigfish" })) {
    needConfigPlugins = false;
  }
  return {
    needInstall,
    needConfigPlugins
  };
}
var GeneratorHelper = class {
  constructor(api) {
    this.api = api;
    const { needInstall, needConfigPlugins } = checkStatus({
      pkg: api.pkg
    });
    this.needInstallUmiPlugin = needInstall;
    this.needConfigUmiPlugin = needConfigPlugins;
  }
  setUmirc(key, val) {
    (0, import_set.set)(this.api, key, val);
  }
  appendInternalPlugin(pluginPath) {
    if (this.needConfigUmiPlugin && !(this.api.userConfig.plugins || []).includes(pluginPath)) {
      this.setUmirc("plugins", (this.api.userConfig.plugins || []).concat(pluginPath));
    }
  }
  addDevDeps(deps) {
    const { api } = this;
    const externalDeps = import_utils.lodash.omit(deps, ["@umijs/plugins"]);
    if (this.needInstallUmiPlugin) {
      api.pkg.devDependencies = {
        ...api.pkg.devDependencies,
        ...deps
      };
      (0, import_fs.writeFileSync)(api.pkgPath, JSON.stringify(api.pkg, null, 2));
      import_utils.logger.info("Write package.json");
    } else if (!import_utils.lodash.isEmpty(externalDeps)) {
      api.pkg.devDependencies = {
        ...api.pkg.devDependencies,
        ...externalDeps
      };
      (0, import_fs.writeFileSync)(api.pkgPath, JSON.stringify(api.pkg, null, 2));
      import_utils.logger.info("Update package.json for devDependencies");
    }
  }
  addScript(name, cmd) {
    const { api } = this;
    this.addScriptToPkg(name, cmd);
    (0, import_fs.writeFileSync)(api.pkgPath, JSON.stringify(api.pkg, null, 2));
    import_utils.logger.info("Update package.json for scripts");
  }
  addScripts(scripts) {
    const { api } = this;
    for (const [name, cmd] of Object.entries(scripts)) {
      this.addScriptToPkg(name, cmd);
    }
    (0, import_fs.writeFileSync)(api.pkgPath, JSON.stringify(api.pkg, null, 2));
    import_utils.logger.info("Update package.json for scripts");
  }
  addScriptToPkg(name, cmd) {
    var _a, _b, _c;
    const { api } = this;
    if (((_a = api.pkg.scripts) == null ? void 0 : _a[name]) && ((_b = api.pkg.scripts) == null ? void 0 : _b[name]) !== cmd) {
      import_utils.logger.warn(`scripts.${name} = "${(_c = api.pkg.scripts) == null ? void 0 : _c[name]}" already exists, will be overwritten with "${cmd}"!`);
    }
    api.pkg.scripts = {
      ...api.pkg.scripts,
      [name]: cmd
    };
  }
  appendGitIgnore(patterns) {
    const { api } = this;
    const gitIgnorePath = (0, import_path.join)(api.cwd, ".gitignore");
    if ((0, import_fs.existsSync)(gitIgnorePath)) {
      const gitIgnore = (0, import_fs.readFileSync)(gitIgnorePath, "utf-8");
      const toAppendPatterns = patterns.filter((pattern) => !gitIgnore.includes(pattern));
      if (toAppendPatterns.length > 0) {
        const toAppend = patterns.join("\n");
        (0, import_fs.writeFileSync)(gitIgnorePath, `${gitIgnore}
${toAppend}`);
        import_utils.logger.info("Update .gitignore");
      }
    }
  }
  installDeps() {
    const { npmClient } = this.api.appData;
    (0, import_utils.installWithNpmClient)({
      npmClient
    });
    import_utils.logger.info(`Install dependencies with ${npmClient}`);
  }
  async ensureVariableWithQuestion(v, question) {
    if (!v) {
      const res = await promptsExitWhenCancel({
        ...question,
        name: "variable"
      });
      return res.variable ? res.variable : question.initial;
    }
    return v;
  }
};
function getUmiJsPlugin() {
  var _a;
  const pkg = require((0, import_path.join)(__dirname, "../../../", "package.json"));
  const pkgVer = import_utils.semver.parse(pkg.version);
  const umijsPluginVersion = ((_a = pkgVer == null ? void 0 : pkgVer.prerelease) == null ? void 0 : _a.length) ? pkg.version : `^${pkg.version}`;
  return umijsPluginVersion;
}
function promptsExitWhenCancel(questions, options) {
  return (0, import_utils.prompts)(questions, {
    ...options,
    onCancel: () => {
      process.exit(1);
    }
  });
}
function trim(s) {
  return (s == null ? void 0 : s.trim()) || "";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GeneratorHelper,
  checkStatus,
  getUmiJsPlugin,
  promptsExitWhenCancel,
  trim
});
