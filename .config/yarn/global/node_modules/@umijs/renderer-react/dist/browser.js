import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useCallback, useEffect, useState } from 'react'; // compatible with < react@18 in @umijs/preset-umi/src/features/react

import ReactDOM from 'react-dom/client';
import { matchRoutes, Router, useRoutes } from 'react-router-dom';
import { AppContext, useAppData } from "./appContext";
import { createClientRoutes } from "./routes";
var root = null; // react 18 some scenarios need unmount such as micro app

export function __getRoot() {
  return root;
}

function BrowserRoutes(props) {
  var history = props.history;

  var _React$useState = React.useState({
    action: history.action,
    location: history.location
  }),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      state = _React$useState2[0],
      setState = _React$useState2[1];

  React.useLayoutEffect(function () {
    return history.listen(setState);
  }, [history]);
  React.useLayoutEffect(function () {
    function onRouteChange(opts) {
      props.pluginManager.applyPlugins({
        key: 'onRouteChange',
        type: 'event',
        args: {
          routes: props.routes,
          clientRoutes: props.clientRoutes,
          location: opts.location,
          action: opts.action,
          basename: props.basename
        }
      });
    }

    history.listen(onRouteChange);
    onRouteChange({
      location: state.location,
      action: state.action
    });
  }, [history, props.routes, props.clientRoutes]);
  return /*#__PURE__*/React.createElement(Router, {
    navigator: history,
    location: state.location,
    basename: props.basename
  }, props.children);
}

export function Routes() {
  var _useAppData = useAppData(),
      clientRoutes = _useAppData.clientRoutes;

  return useRoutes(clientRoutes);
}
export function renderClient(opts) {
  var basename = opts.basename || '/';
  var rootElement = opts.rootElement || document.getElementById('root');
  var clientRoutes = createClientRoutes({
    routesById: opts.routes,
    routeComponents: opts.routeComponents,
    loadingComponent: opts.loadingComponent,
    reactRouter5Compat: opts.reactRouter5Compat
  });
  opts.pluginManager.applyPlugins({
    key: 'patchClientRoutes',
    type: 'event',
    args: {
      routes: clientRoutes
    }
  });
  var rootContainer = /*#__PURE__*/React.createElement(BrowserRoutes, {
    basename: basename,
    pluginManager: opts.pluginManager,
    routes: opts.routes,
    clientRoutes: clientRoutes,
    history: opts.history
  }, /*#__PURE__*/React.createElement(Routes, null));

  for (var _i = 0, _arr = [// Lowest to the highest priority
  'innerProvider', 'i18nProvider', 'accessProvider', 'dataflowProvider', 'outerProvider', 'rootContainer']; _i < _arr.length; _i++) {
    var key = _arr[_i];
    rootContainer = opts.pluginManager.applyPlugins({
      type: 'modify',
      key: key,
      initialValue: rootContainer,
      args: {}
    });
  }

  var Browser = function Browser() {
    var _useState = useState({}),
        _useState2 = _slicedToArray(_useState, 2),
        clientLoaderData = _useState2[0],
        setClientLoaderData = _useState2[1];

    var _useState3 = useState( // @ts-ignore
    window.__UMI_LOADER_DATA__ || {}),
        _useState4 = _slicedToArray(_useState3, 2),
        serverLoaderData = _useState4[0],
        setServerLoaderData = _useState4[1];

    var handleRouteChange = useCallback(function (id, isFirst) {
      var _matchRoutes;

      // Patched routes has to id
      var matchedRouteIds = (((_matchRoutes = matchRoutes(clientRoutes, id, basename)) === null || _matchRoutes === void 0 ? void 0 : _matchRoutes.map( // @ts-ignore
      function (route) {
        return route.route.id;
      })) || []).filter(Boolean);
      matchedRouteIds.forEach(function (id) {
        var _opts$routes$id, _opts$routes$id2;

        // preload
        // @ts-ignore
        var manifest = window.__umi_manifest__;

        if (manifest) {
          var routeIdReplaced = id.replace(/[\/\-]/g, '_');
          var preloadId = "preload-".concat(routeIdReplaced, ".js");

          if (!document.getElementById(preloadId)) {
            var keys = Object.keys(manifest).filter(function (k) {
              return k.startsWith(routeIdReplaced + '.');
            });
            keys.forEach(function (key) {
              if (!/\.(js|css)$/.test(key)) {
                throw Error("preload not support ".concat(key, " file"));
              }

              var file = manifest[key];
              var link = document.createElement('link');
              link.rel = 'preload';
              link.as = 'style';

              if (key.endsWith('.js')) {
                link.as = 'script';
                link.id = preloadId;
              } // publicPath already in the manifest,
              // but if runtimePublicPath is true, we need to replace it


              if (opts.runtimePublicPath) {
                file = file.replace(new RegExp("^".concat(opts.publicPath)), // @ts-ignore
                window.publicPath);
              }

              link.href = file;
              document.head.appendChild(link);
            });
          }
        } // server loader
        // use ?. since routes patched with patchClientRoutes is not exists in opts.routes


        if (!isFirst && (_opts$routes$id = opts.routes[id]) !== null && _opts$routes$id !== void 0 && _opts$routes$id.hasServerLoader) {
          fetch('/__serverLoader?route=' + id).then(function (d) {
            return d.json();
          }).then(function (data) {
            // setServerLoaderData when startTransition because if ssr is enabled,
            // the component may being hydrated and setLoaderData will break the hydration
            React.startTransition(function () {
              setServerLoaderData(function (d) {
                return _objectSpread(_objectSpread({}, d), {}, _defineProperty({}, id, data));
              });
            });
          }).catch(console.error);
        } // client loader
        // onPatchClientRoutes 添加的 route 在 opts.routes 里是不存在的


        var clientLoader = (_opts$routes$id2 = opts.routes[id]) === null || _opts$routes$id2 === void 0 ? void 0 : _opts$routes$id2.clientLoader;

        if (clientLoader && !clientLoaderData[id]) {
          clientLoader().then(function (data) {
            setClientLoaderData(function (d) {
              return _objectSpread(_objectSpread({}, d), {}, _defineProperty({}, id, data));
            });
          });
        }
      });
    }, [clientLoaderData]);
    useEffect(function () {
      handleRouteChange(window.location.pathname, true);
      return opts.history.listen(function (e) {
        handleRouteChange(e.location.pathname);
      });
    }, []);
    return /*#__PURE__*/React.createElement(AppContext.Provider, {
      value: {
        routes: opts.routes,
        routeComponents: opts.routeComponents,
        clientRoutes: clientRoutes,
        pluginManager: opts.pluginManager,
        rootElement: opts.rootElement,
        basename: basename,
        clientLoaderData: clientLoaderData,
        serverLoaderData: serverLoaderData,
        preloadRoute: handleRouteChange,
        history: opts.history
      }
    }, rootContainer);
  };

  if (opts.hydrate) {
    ReactDOM.hydrateRoot(rootElement, /*#__PURE__*/React.createElement(Browser, null));
  } else {
    if (ReactDOM.createRoot) {
      root = ReactDOM.createRoot(rootElement);
      root.render( /*#__PURE__*/React.createElement(Browser, null));
    } else {
      // @ts-ignore
      ReactDOM.render( /*#__PURE__*/React.createElement(Browser, null), rootElement);
    }
  }
}